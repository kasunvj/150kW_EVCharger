/// <reference path="../src/can.d.ts" />
import * as can from "../build/Release/can.node";
import * as kcd from "./parse_kcd";
/**
 * @method createRawChannel
 * @param channel {string} Channel name (e.g. vcan0)
 * @param timestamps {bool} Whether or not timestamps shall be generated when reading a message
 * @param protocol {integer} optionally provide another default protocol value (default is CAN_RAW)
 * @return {RawChannel} a new channel object or exception
 * @for exports
 */
export declare function createRawChannel(channel: string, timestamps?: boolean, protocol?: number): can.RawChannel;
interface ChannelOptions {
    timestamps?: boolean;
    protocol?: number;
    non_block_send?: boolean;
}
/**
 * @method createRawChannelWithOptions
 * @param channel {string} Channel name (e.g. vcan0)
 * @param options {dict} list of options (timestamps, protocol, non_block_send)
 * @return {RawChannel} a new channel object or exception
 * @for exports
 */
export declare function createRawChannelWithOptions(channel: string, options: ChannelOptions): can.RawChannel;
/**
 * The actual signal.
 * @class Signal
 */
export declare class Signal extends kcd.Signal {
    readonly muxGroup: number[];
    value?: number;
    changeListeners: CallableFunction[];
    updateListeners: CallableFunction[];
    constructor(desc: kcd.Signal);
    /**
     * Keep track of listeners who want to be notified if this signal changes
     * @method onChange
     * @param listener JS callback to get notification
     * @for Signal
     */
    onChange(listener: CallableFunction): CallableFunction;
    /**
     * Keep track of listeners who want to be notified if this signal updates
     * @method onUpdate
     * @param listener JS callback to get notification
     * @for Signal
     */
    onUpdate(listener: CallableFunction): CallableFunction;
    /**
     * Remove listener from signal onChange and/or onUpdate
     * @method removeListener
     * @param listener to be removed
     * @for Signal
     */
    removeListener(listener: CallableFunction): void;
    /**
     * Set new value of this signal. Any local registered clients will
     * receive a notification. Please note, no CAN message is actually
     * send to the bus (@see DatabaseServer::send)
     * @method update
     * @param newValue {bool|double|integer} New value to set
     * @for Signal
     */
    update(newValue: number): void;
}
/**
 * Just a container to keep the Signals.
 * @class Message
 */
export declare class Message {
    readonly id: number;
    readonly name: string;
    readonly ext: boolean;
    readonly len: number;
    readonly interval: number;
    readonly muxed: boolean;
    readonly mux: kcd.Mux | undefined;
    readonly signals: Record<string, Signal>;
    constructor(msgDef: kcd.Message);
}
/**
 * A DatabaseService is usually generated once per bus to collect signals
 * coded in the CAN messages according a DB description.
 * @class DatabaseService
 * @constructor DatabaseService
 * @param channel RAW channel
 * @param db_desc Set of rules to decode/encode signals (@parse_kcd.js)
 * @return a new DatabaseService
 * @for DatabaseService
 */
export declare class DatabaseService {
    private channel;
    readonly messages: Record<string, Message>;
    constructor(channel: can.RawChannel, busDef: kcd.Bus);
    onMessage(msg: can.Message): void;
    /**
     * Construct a CAN message and encode all related signals according
     * the rules. Finally send the message to the bus.
     * @method send
     * @param msg_name Name of the message to generate (indicate mux by append .MUX_VALUE in hex)
     * @for DatabaseService
     */
    send(msg_name: string): void;
}
/**
 * @method parseNetworkDescription
 * @param file {string} Path to KCD file to parse
 * @return DB description to be used in DatabaseService
 * @for exports
 */
export declare const parseNetworkDescription: typeof kcd.parseKcdFile;
export { kcd };
//# sourceMappingURL=socketcan.d.ts.map